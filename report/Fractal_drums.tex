\documentclass{article}
\usepackage[margin=2cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage{todo}
\usepackage{url}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\usepackage{float}

\definecolor{aliceblue}{rgb}{0.94, 0.97, 1.0}
\definecolor{almond}{rgb}{0.94, 0.87, 0.8}
\definecolor{asparagus}{rgb}{0.53, 0.66, 0.42}
\definecolor{gainsboro}{rgb}{0.86, 0.86, 0.86}
\definecolor{gray(x11gray)}{rgb}{0.75, 0.75, 0.75}

\lstset{frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
  language=C
}

\title{Fractal Drums}
\author{Knut Andre G. Prestsveen}
\begin{document}
\maketitle


\section{Abstract}
A numerical study of vibrations of fractal shaped drums. The 10 lowest vibration eigenmodes for a drum with a   fractal shaped boundary were computed using finite diferences, and the scaling of the integrated density of states were compared with the Weyl-conjecture and results for drums with smooth boundary.

\section{Introduction}
For any drum, it's size is related to the pitch of the sound it makes, and the larger the area, the lower the pitch. The question in mind for this study, is if the shape of the drum also affects the tone so that information about the drum's shape can be inferred from the tone, and this study spesifically studied drums shaped like quadratic Koch fractals.

The study was carried out numerically, and program code for generating the fractal and a system lattice, representing the drums boundary and skin respectively, were written. The eigenmodes of the drums vibration were then computed with finite differences, and to see if the Weyl-conjecture could could be used to infer information about the fractal boundary, the integrated density of states of the fractal drum were compared to that of a drum with smooth boundary and same area.

\section{Theory}\label{theory}
\subsection{The Weyl-conjecture}
The shape of the drum cannot be completely inferred from it's sound alone, but some information can be extracted. Firstly the area of the drum $A$ can be found from

\begin{equation}
    \label{eq:area}
    A = 4\pi \lim_{\omega \to \infty} \frac{N(\omega)}{\omega^2}... ,
\end{equation}
where $N(\omega)$ is the integrated density of states (IDOS), i.e. the number of eigenfrequencies smaller than the frequency $\omega$. Also Hermann Weyl conjectured that the second term in the asymptotic of $N(\omega)$ gives the length of the drums perimeter $L$, so that

\begin{equation}
    \label{eq:weyl-conjecture}
    N(\omega) = \frac{A}{4\pi}\omega^2 - \frac{L}{4\pi}\omega+...
\end{equation}
in the limit of large $\omega$. Equation \ref{weyl-conjecture} is the Weyl-conjecture for the IDOS, and is proven correct under the assumption of a smooth boundary. This study tries to see what happens when the boundary is fractal.

\subsection{Quadratic Koch Fractal}\label{theory-koch}
The quadratic koch fractal is recursively generated by starting out with a square, dividing each of the sides into four equal pieces, and displace the two middle pieces one side length, one of them up the other down. This process is repeated recursively until reached desired recursion depth. The process is illustrated in \ref{generate-koch}.

\begin{figure}[tbp]
    \includegraphics[width=\linewidth, trim={0 3cm 0 3cm}]{./media/koch_frac_step.pdf}
    \caption{Koch fractal}
    \label{generate-koch}
\end{figure}

\subsection{The Helmholtz equation - Finite Difference Approximation}
The displacement of the drum's surface $u(r, t)$ is given by the wave equation \ref{eq:wave-equation}, with the boundary conditions $u = 0$ on the boundary $\partial \Omega$. Performing the Fourier transform of the wave equation \ref{eq:wave-equation} results in the Helmholtz equation \ref{eq:helmholtz-equation}, and turns the problem into an eigenvalue problem.

\begin{equation}
    -\nabla^2u = \frac{1}{v^2}\frac{\partial^2 u}{\partial t^2}
    \label{eq:wave-equation}
\end{equation}

\begin{equation}
    -\nabla^2U(\textbf{x}, \omega) = \frac{\omega^2}{v^2}U(\textbf{x}, \omega)
    \label{eq:helmholtz-equation}
\end{equation}

The eigen values, and vectors of equation \ref{eq:helmholtz-equation} were calculated using finite differences, with both the stantard five-point stensil and the nine-point stensil approximation to the laplacian operator. The discretization of equation \ref{eq:helmholtz-equation} becomes

\begin{equation}
    five point
    \label{eq:five-point}
\end{equation}

and

\begin{equation}
    nine point
    \label{eq:five-point}
\end{equation}

for the five point and nine point approximations respectively.

\section{Code}
The program code is written in the julia language, the setup of the system is split into several files, which are all included in \colorbox{gainsboro}{\lstinline{setup.jl}}. The main script is \colorbox{gainsboro}{\lstinline{main.jl}}, which includes \colorbox{gainsboro}{\lstinline{setup.jl}} and solves the eigenvalue problem using the \colorbox{gainsboro}{\lstinline{eigs}} routine for sparse matrices from the ARPACK library.\\

\subsection{Fractal creation}\label{code:fractal}
The generation of the fractal is just a straight forward implementation of the recursive method described in \ref{theory-koch}. The code was split into three functions: firstly there is \colorbox{gainsboro}{\lstinline{generate_side}} which takes the start and end point of a side and returns the "transformed" side and \colorbox{gainsboro}{\lstinline{generate_corners}} which calls \colorbox{gainsboro}{\lstinline{generate_side}} for every side in the current fractal shape and for every level recursively, returning the alle the positions of the fractals corners.
Finally there is \colorbox{gainsboro}{\lstinline{fill_edges}} which places points on the sides between the corners, according to the specified grid constant.\\

\subsection{Determation of inside points}\label{code:determine-inside}
The determination of which points are inside is done with a breadth first like search, starting in the middle point which is known to be inside the fractal. Another method which was implemented starts in a point, scans towards the edge in one direction and uses the orientation of the curve to determin if the point was inside or not. The latter requieres that the fractals points are ordered correctly, was considerably slower, and while it could have been sped up considerably by determining every point along each scan in one go, this was not done
since the former method seemed more elegant. The lattice is first initialized with every element being \colorbox{gainsboro}{\lstinline{OUTSIDE}}, and the breadth search code is shown in listing \ref{lst:lattice-bfs}.\\

\begin{lstlisting}[label=lst:lattice-bfs]
    # --snip--    

    points = [left, right, down, up] 
    println("begin search")
    for point in points
        x, y = point
        if lattice[x, y] == OUTSIDE
            # New INSIDE point
            lattice[x, y] = INSIDE

            # Add nearest neighbours to points
            for nn in (-1, 1)
                    push!(points, (x + nn, y)) 
                    push!(points, (x, y + nn))
            end
        else
            continue
        end
    end 

    # --snip--    
\end{lstlisting}

\subsection{Datastructures}
The drum's surface is represented by a lattice, which in the code is a 2D array containing an integer value representing the points location. Every point outside the fractal is set to \colorbox{gainsboro}{\lstinline{OUTSIDE_POINT = -1}} and points on the border are set to \colorbox{gainsboro}{\lstinline{BORDER_POINT = 0}}. The points inside are numbered by positive integers, which corresponds to their inner index in the
later contructed laplacian matrix. Each points location value is determined by the process described in section \ref{code:determine-inside}, and the positions of the
points on the lattice are corresponding to the \colorbox{gainsboro}{\lstinline{CartesianIndices}} of the array.

For the alternative method of lattice creation, a slightly different representation was used. The lattice was then an array of the custom type \colorbox{gainsboro}{\lstinline{Point}}, which contains the membervariables \colorbox{gainsboro}{\lstinline{x::Int}}, \colorbox{gainsboro}{\lstinline{y::Int}} and \colorbox{gainsboro}{\lstinline{location::Location}}, where the latter is a custom enum type. The definitions of \colorbox{gainsboro}{\lstinline{Point}} and \colorbox{gainsboro}{\lstinline{Location}}
is shown in listing \ref{lst:datastructures}.\\

\begin{lstlisting}[label=lst:datastructures]
@enum Location INSIDE OUTSIDE BORDER


struct Point
    x::Int
    y::Int
    location::Location
end
\end{lstlisting}


\noindent
\textbf{Creation of laplacian matrix}\\
The negative laplacian matrix construction is also quite straight forward. It constructs the matrix row by row by looping through every lattice point inside the fractal, setting the diagonal elements to $4$ and the nearest neighbour elements to $-1$ if the neighbour also is an inside point. The definition of the function setting up the five point matrix is shown in listing \ref{code:five-point}, and the nine point version is completely analogous.\\

\begin{lstlisting}[label=code:five-point]
function five_point_laplacian(N, lattice, points_inside)
    println("Making laplacian matrix")
    lap_matrix = spzeros(N, N)
    for (idx, p) in enumerate(points_inside)
        x, y = p 
        lap_matrix[idx, idx] = 4 
        for nn in (-1, 1)
            if lattice[x+nn, y] == INSIDE
                nn_idx = findfirst(p -> p== (x+nn, y), points_inside)
                lap_matrix[idx, nn_idx] = -1
            end
            if lattice[x, y+nn] == INSIDE
                nn_idx = findfirst(p -> p== (x, y+nn), points_inside)
                lap_matrix[idx, nn_idx] = -1
            end
        end
    end 
    return lap_matrix
end
\end{lstlisting}

\section{Results and discussion}

\subsection{Determin inside comparison}
The breadth first search is much more efficient than the naive traverse search, and can hangle much larger lattices. The traverse search can probably be improved upon to be comparable to the breadth search, but as the implementations are now the former method takes seconds where the latter method spends minutes. The breadth first search is efficient enough so that it never is a bottle neck for the computation. 

\subsection{Solutions to EV}
Table of eigenvalues (at least 10), ref to plots
The highes fractal level my computer and code was able to handle was level 5, and table \ref{table:eigenvals} shows the 10 lowest eigenvalues at different levels and grid resolutions. The limitation of the computation is the \colorbox{gainsboro}{\lstinline{eigs}} routine
from Arpack, which is the most time and memory consuming part of the code for higher levels, and also plotting of the eigenstates takes quite some time at for high levels and grid resolutions. The correspunding eigenstates, but for a level 4 fractal, are shown in figure \ref{fig:2dmodes}\\

\begin{tabular}{|c|c|c|}
    level=5, gridres=1   &  level=4, gridres=1 &    level=3, gridres=4\\
    \hline
    2.1172036732026874e-5   &   0.00033779615002478065  &   0.0008493414391754176\\
    4.761205170693104e-5    &   0.000758455377648222    &   0.0018882176645521438\\
    4.761205170693165e-5    &   0.0007584553776482244   &   0.0018882176645521613\\
    4.946353369683679e-5    &   0.0007878141802701458   &   0.0019595798224599993\\
    4.999806796113937e-5    &   0.0007964587750657883   &   0.0019832717170220697\\
    5.416492483189804e-5    &   0.0008640818302252861   &   0.0021717340723473185\\
    5.4164924831898765e-5   &   0.0008640818302252886   &   0.0021717340723473276\\
    7.421330675523835e-5    &   0.0011835480338816295   &   0.0029687326189671865\\
    8.512772404960623e-5    &   0.0013571443191111746   &   0.003396846897119718\\
    9.011148145688274e-5    &   0.0014365248772246742   &   0.0035942764169037233
    \label{table:eigenvals}
\end{tabular}

\subsection{Largest value of L, memory}
As mentioned, the highest level I was able to compute the eigenvalues at, was level 5, and that was only with a low grid resolution. For higher levels the process is simply killed because it runs out of memory, and my computer has $8GB$ of memory, but in reality $7.66Gb$ is available according to htop. Simply storing the laplacian matrix does almost not use any memory at all, because it is very sparse and only contains two different integer values. It is stored as a
\colorbox{gainsboro}{\lstinline{SparseArray}}, and the \colorbox{gainsboro}{\lstinline{eigs}} solver from Arpack is a sparse solver. For level 5, grid resolution 1, the laplacian matrix requires only $4e-5 MB$, which is a negigible amount of memory compared to the computers RAM. 

This means that the thing preventing computation of higher levels is Arpack's \colorbox{gainsboro}{\lstinline{eigs}}, and therefore it is not easy to think of anything that can be done to compute for higher levels, except for simply using a more powerfull computer with a lot of memory. However, figure \ref{fig:laplacian-matrix} reveals that the laplacian matrix is not only very sparse, but also symmetric, and this can possibly be exploited to save
some computer resources.

Additionally, I read about a similar problem *REF?* where they had defined the stensil to use the diagonal neigbouring points, and indexed the lattice as a chess board. This allowed them to split the computation in two concurrent parts, as odd and even indexed points could be computed completely independent of each other. This could also perhaps implemented for this problem.

\subsection{IDOS}
According to the wayl conjecture, the integrates density of states is supposed to scale as $\omega^{d}$, where $d$ is th borders fractal dimension. In the limit of a smooth perimeter, the Koch fractal has $d = 1.5$, so we expect our estimates for $d$ to approach this value for higher level fractals. The plot in \ref{fig:idis} shows the regression curves for $\omega ^{d}$, and the estimates for $d$ at each level is listed in table \ref{table:idos}. Note that the reason there are so few
eigenfrequencies for level 5 is that the number of values I was able to compute was limited by my computers memory.\\

\begin{tabular}{ |c|c|c| }
    \hline
    level   &   gridres &   d\\
    \hline
    3   &   4   &   1.3126325672146508\\
    4   &   1   &   1.3736896123492528\\
    5   &   1   &   1.4994142369831907
    \label{table:idos}
\end{tabular}


\subsection{Compare 9p to 5p stensil}
An implementation of a nine point stensil approximation to the laplacian was also implemented...


\begin{figure}[H]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\linewidth]{./media/quad_koch_level2.pdf}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\linewidth]{./media/quad_koch_level3.pdf}
    \end{subfigure}
    \caption{Quadratic koch fractals of recursion depth 2 and 3, generated by the code described in \ref{code:fractal}}
\end{figure}

\begin{figure}
    \includegraphics[width=\linewidth]{./media/idos.pdf}
    \caption{Regression curves for the scaling of the eigenfrequencies.}
    \label{fig:idos}
\end{figure}

\begin{figure}
    \includegraphics[width=\linewidth]{./media/laplacian_matrix.pdf}
    \caption{The laplacian matrix for recursion depth 1 and grid res 2.}
    \label{fig:laplacian-matrix}
\end{figure}

\begin{figure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d1.png}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d2.png}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d3.png}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d4.png}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d5.png}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d6.png}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d7.png}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d8.png}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d9.png}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \includegraphics[width=\linewidth]{./media/eigenmode_2d10.png}
    \end{subfigure}
    \caption{The 10 lowest eigenmodes, 2D plots.}
    \label{fig:2dmodes}
\end{figure}

\end{document}

